<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Juego de la Rana Corregido y Seguro</title>
<style>
Â  * { box-sizing: border-box; }
Â  html, body {
Â  Â  margin: 0; padding: 0; height: 100%;
Â  Â  background: #112;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  align-items: center;
Â  Â  color: #eee;
Â  Â  font-family: 'Inter', Arial, sans-serif;
Â  Â  user-select: none;
Â  Â  -webkit-tap-highlight-color: transparent;
Â  }
Â  #scoreboard {
Â  Â  width: 100%;
Â  Â  max-width: 600px;
Â  Â  display: flex;
Â  Â  justify-content: space-between;
Â  Â  font-size: 1.4rem;
Â  Â  padding: 10px 15px;
Â  Â  box-sizing: border-box;
Â  Â  background: #234;
Â  Â  border-radius: 8px 8px 0 0;
Â  }
Â  #livesDisplay {
Â  Â  color: #f00;
Â  }
Â  #completionMessage {
Â  Â  margin-top: 10px;
Â  Â  font-size: 1.6rem;
Â  Â  font-weight: bold;
Â  Â  color: #0ff;
Â  Â  text-align: center;
Â  Â  min-height: 44px;
Â  Â  user-select: text;
Â  }
Â  canvas {
Â  Â  background: #045; /* RÃ­o/Carretera base */
Â  Â  border: 3px solid #444;
Â  Â  touch-action: none;
Â  Â  max-width: 100vw;
Â  Â  height: 90vw;
Â  Â  max-height: 550px;
Â  Â  width: 100%;
Â  Â  display: block;
Â  }
Â  /* Estilos para el D-Pad */
Â  #controls {
Â  Â  display: grid;
Â  Â  grid-template-areas: ". up ." "left center right" ". down .";
Â  Â  width: 100%;
Â  Â  max-width: 260px; /* Ajustado para mÃ³vil */
Â  Â  margin-top: 15px;
Â  Â  gap: 6px;
Â  Â  user-select: none;
Â  Â  justify-content: center;
Â  }
Â  .d-pad-btn {
Â  Â  background-color: #4a5c88;
Â  Â  color: white;
Â  Â  font-size: 1.1rem;
Â  Â  padding: 10px 0;
Â  Â  border: none;
Â  Â  border-radius: 8px;
Â  Â  box-shadow: 0 4px #2b395b;
Â  Â  cursor: pointer;
Â  Â  transition: background-color 0.1s, box-shadow 0.1s;
Â  Â  touch-action: manipulation;
Â  Â  width: 60px;
Â  Â  height: 48px;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  }
Â  .d-pad-btn:active {
Â  Â  background-color: #3e4d70;
Â  Â  box-shadow: 0 1px #2b395b;
Â  Â  transform: translateY(3px);
Â  }
Â  #btn-up { grid-area: up; }
Â  #btn-down { grid-area: down; }
Â  #btn-left { grid-area: left; }
Â  #btn-right { grid-area: right; }
Â  #btn-center { grid-area: center; visibility: hidden; }

Â  /* Iconos de flecha (Font Awesome) */
Â  .arrow::before {
Â  Â  font-family: "Font Awesome 5 Free";
Â  Â  font-weight: 900;
Â  }
Â  #btn-up::before { content: "\f0d8"; }
Â  #btn-down::before { content: "\f0d7"; }
Â  #btn-left::before { content: "\f0d9"; }
Â  #btn-right::before { content: "\f0da"; }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>

<div id="scoreboard" aria-live="polite" aria-atomic="true">
Â  <div>Vidas: <span id="livesDisplay">ğŸ’šğŸ’šğŸ’š</span></div>
Â  <div>Metas: <span id="goalsCompleted">0/5</span></div>
</div>

<canvas id="gameCanvas" width="550" height="550" aria-label="Ãrea de juego de la rana con trÃ¡fico denso y zona de seguridad intermedia" role="img" tabindex="0"></canvas>

<div id="completionMessage" aria-live="assertive" aria-atomic="true"></div>

<div id="controls" role="group" aria-label="Controles de direcciÃ³n tÃ¡ctiles para la rana">
Â  <button id="btn-up" class="d-pad-btn arrow" data-direction="up" aria-label="Mover arriba" tabindex="0"></button>
Â  <button id="btn-left" class="d-pad-btn arrow" data-direction="left" aria-label="Mover izquierda" tabindex="0"></button>
Â  <div id="btn-center"></div>
Â  <button id="btn-right" class="d-pad-btn arrow" data-direction="right" aria-label="Mover derecha" tabindex="0"></button>
Â  <button id="btn-down" class="d-pad-btn arrow" data-direction="down" aria-label="Mover abajo" tabindex="0"></button>
</div>

<script>
(() => {
Â  const canvas = document.getElementById('gameCanvas');
Â  const ctx = canvas.getContext('2d');
Â  const completionMessageElem = document.getElementById('completionMessage');
Â  const livesDisplayElem = document.getElementById('livesDisplay');
Â  const goalsCompletedElem = document.getElementById('goalsCompleted');

Â  // Dimensiones del Canvas
Â  const WIDTH = 550;Â 
Â  const HEIGHT = 550;

Â  // DPI fix
Â  function fixDPI() {
Â  Â  const dpi = window.devicePixelRatio || 1;
Â  Â  canvas.style.width = WIDTH + 'px';
Â  Â  canvas.style.height = HEIGHT + 'px';
Â  Â  if (canvas.width !== WIDTH * dpi || canvas.height !== HEIGHT * dpi) {
Â  Â  Â  canvas.width = WIDTH * dpi;
Â  Â  Â  canvas.height = HEIGHT * dpi;
Â  Â  Â  ctx.setTransform(1, 0, 0, 1, 0, 0);
Â  Â  Â  ctx.scale(dpi, dpi);
Â  Â  }
Â  }
Â  fixDPI();

Â  // --- Zonas de Juego (Ajustadas para 4 carriles de cada + Medianera de 50px) ---
Â  const SAFE_ZONE_TOP_HEIGHT = 50;Â 
Â  const SAFE_ZONE_BOTTOM_HEIGHT = 50;Â 
Â  const MEDIAN_HEIGHT = 50; // Â¡NUEVA ZONA SEGURA INTERMEDIA!
Â Â 
Â  const ROAD_LANES_COUNT = 4; // 4 carriles de carretera
Â  const RIVER_LANES_COUNT = 4; // 4 carriles de rÃ­o
Â  const TOTAL_LANES = ROAD_LANES_COUNT + RIVER_LANES_COUNT; // 8
Â Â 
Â  // (550 - 50 - 50 - 50) / 8 = 400 / 8 = 50px
Â  const LANE_HEIGHT = (HEIGHT - SAFE_ZONE_BOTTOM_HEIGHT - SAFE_ZONE_TOP_HEIGHT - MEDIAN_HEIGHT) / TOTAL_LANES; // 50px

Â  const ROAD_HEIGHT = LANE_HEIGHT * ROAD_LANES_COUNT; // 200px
Â  const RIVER_HEIGHT = LANE_HEIGHT * RIVER_LANES_COUNT; // 200px
Â Â 
Â  // Frog constants
Â  const FROG_SIZE = 25;Â 
Â  const FROG_STEP = LANE_HEIGHT; // El paso es igual a la altura del carril (50px)
Â  const FROG_START_X = WIDTH / 2 - FROG_SIZE / 2;
Â  const FROG_START_Y = HEIGHT - FROG_STEP + (FROG_STEP - FROG_SIZE) / 2;
Â Â 
Â  // Velocidades y dimensiones de objetos (similares a antes, pero mÃ¡s pequeÃ±os)
Â  const VEHICLE_HEIGHT = FROG_SIZE + 5;Â 
Â  const VEHICLE_SPEED_MIN = 1.0;Â 
Â  const VEHICLE_SPEED_MAX = 2.8;Â 

Â  const LOG_WIDTH = 100;Â 
Â  const LOG_HEIGHT = FROG_SIZE + 5;
Â  const LOG_SPEED_MIN = 1.2;Â 
Â  const LOG_SPEED_MAX = 2.2;Â 

Â  const CROCODILE_WIDTH = 70;Â 
Â  const CROCODILE_HEIGHT = FROG_SIZE + 5;
Â  const CROCODILE_SPEED_MIN = 1.1;Â 
Â  const CROCODILE_SPEED_MAX = 2.0;Â 
Â Â 
Â  // Goal constants
Â  const GOAL_COUNT = 5;
Â  const GOAL_WIDTH = FROG_SIZE + 10;
Â  let goals = [];Â 
Â  let goalPositions = [];Â 

Â  // Game state
Â  let lives = 3;Â 
Â  let gameEnded = false;
Â  let isRespawning = false; // Â¡NUEVO! Evita doble muerte
Â  let frogX = FROG_START_X;
Â  let frogY = FROG_START_Y;
Â  let vehicles = [];
Â  let logs = [];
Â  let crocodiles = [];

Â  // Posiciones Y de los centros de los carriles
Â  let riverLaneYs = [];
Â  for (let i = 0; i < RIVER_LANES_COUNT; i++) {
Â  Â  // 50 (Safe Zone Top) + (i * 50) + 25
Â  Â  riverLaneYs.push(SAFE_ZONE_TOP_HEIGHT + (i * LANE_HEIGHT) + LANE_HEIGHT / 2);
Â  }

Â  let roadLaneYs = [];
Â  for (let i = 0; i < ROAD_LANES_COUNT; i++) {
Â  Â  // Comienza despuÃ©s de SafeZoneTop + River + Median
Â  Â  const roadStartY = SAFE_ZONE_TOP_HEIGHT + RIVER_HEIGHT + MEDIAN_HEIGHT;
Â  Â  roadLaneYs.push(roadStartY + (i * LANE_HEIGHT) + LANE_HEIGHT / 2);
Â  }

Â  // Goal Positions
Â  function initGoalPositions() {
Â  Â  goalPositions = [];
Â  Â  const goalSpacing = (WIDTH - GOAL_COUNT * GOAL_WIDTH) / (GOAL_COUNT + 1);
Â  Â  for (let i = 0; i < GOAL_COUNT; i++) {
Â  Â  Â  Â  const x = goalSpacing * (i + 1) + i * GOAL_WIDTH;
Â  Â  Â  Â  goalPositions.push({
Â  Â  Â  Â  Â  Â  x: x,
Â  Â  Â  Â  Â  Â  y: 0,Â 
Â  Â  Â  Â  Â  Â  width: GOAL_WIDTH,
Â  Â  Â  Â  Â  Â  height: SAFE_ZONE_TOP_HEIGHTÂ 
Â  Â  Â  Â  });
Â  Â  }
Â  }


Â  function getRandomRange(min, max) {
Â  Â  return Math.random() * (max - min) + min;
Â  }

Â  // FunciÃ³n genÃ©rica para inicializar objetos SIN SOLAPAMIENTO
Â  function initLaneObjects(laneYs, objHeight, minW, maxW, minS, maxS, type) {
Â  Â  let objects = [];
Â  Â Â 
Â  Â  laneYs.forEach((laneCenterY, i) => {
Â  Â  Â  let laneY = laneCenterY - objHeight / 2;
Â  Â  Â  let direction = i % 2 === 0 ? 1 : -1; // DirecciÃ³n alterna
Â  Â  Â Â 
Â  Â  Â  const desiredCount = 4 + Math.floor(Math.random() * 2); // MÃ¡s objetos
Â  Â  Â  const buffer = 20; // Espacio mÃ­nimo entre objetos
Â  Â  Â Â 
Â  Â  Â  let currentX = direction > 0 ? -100 : WIDTH + 100; // PosiciÃ³n inicial
Â  Â  Â  let totalWidth = 0; // Para calcular el ancho total de los objetos en la calle

Â  Â  Â  for (let j = 0; j < desiredCount; j++) {
Â  Â  Â  Â  let width = getRandomRange(minW, maxW);
Â  Â  Â  Â  let speed = getRandomRange(minS, maxS);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Espacio libre mÃ­nimo antes de colocar el siguiente objeto
Â  Â  Â  Â  const minGap = width + buffer;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (direction > 0) {
Â  Â  Â  Â  Â  Â  // Se mueven a la derecha: el objeto se coloca a la izquierda de 'currentX'
Â  Â  Â  Â  Â  Â  currentX -= getRandomRange(minGap, minGap + 150) + width;
Â  Â  Â  Â  Â  Â  if (j === 0) currentX = getRandomRange(-WIDTH, -WIDTH / 2); // Inicio aleatorio fuera de pantalla
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // Se mueven a la izquierda: el objeto se coloca a la derecha de 'currentX'
Â  Â  Â  Â  Â  Â  currentX += getRandomRange(minGap, minGap + 150) + width;
Â  Â  Â  Â  Â  Â  if (j === 0) currentX = getRandomRange(WIDTH * 1.5, WIDTH * 2); // Inicio aleatorio fuera de pantalla
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  objects.push({
Â  Â  Â  Â  Â  x: currentX,
Â  Â  Â  Â  Â  y: laneY,
Â  Â  Â  Â  Â  width: width,
Â  Â  Â  Â  Â  height: objHeight,
Â  Â  Â  Â  Â  speed: speed,
Â  Â  Â  Â  Â  direction: direction,
Â  Â  Â  Â  Â  color: (type === 'vehicle' && direction > 0) ? '#d22' : (type === 'vehicle' ? '#2a2' : (type === 'log' ? '#864c0c' : '#256622')),
Â  Â  Â  Â  Â  type: type
Â  Â  Â  Â  });
Â  Â  Â  Â  totalWidth += width + buffer;
Â  Â  Â  }
Â  Â  });
Â  Â Â 
Â  Â  return objects;
Â  }

Â  function initVehicles() {
Â  Â  Â  vehicles = initLaneObjects(roadLaneYs, VEHICLE_HEIGHT, 30, 60, VEHICLE_SPEED_MIN, VEHICLE_SPEED_MAX, 'vehicle');
Â  }

Â  function initLogs() {
Â  Â  Â  // 4 carriles de rÃ­o. Troncos en los carriles 0 y 2
Â  Â  Â  logs = initLaneObjects(riverLaneYs.filter((_, i) => i % 2 === 0), LOG_HEIGHT, LOG_WIDTH, LOG_WIDTH, LOG_SPEED_MIN, LOG_SPEED_MAX, 'log');
Â  }

Â  function initCrocodiles() {
Â  Â  Â  // 4 carriles de rÃ­o. Cocodrilos en los carriles 1 y 3
Â  Â  Â  crocodiles = initLaneObjects(riverLaneYs.filter((_, i) => i % 2 !== 0), CROCODILE_HEIGHT, CROCODILE_WIDTH, CROCODILE_WIDTH, CROCODILE_SPEED_MIN, CROCODILE_SPEED_MAX, 'croc');
Â  }

Â  function initGoals() {
Â  Â  Â  goals = new Array(GOAL_COUNT).fill(false);
Â  Â  Â  updateGoalsDisplay();
Â  }
Â Â 
Â  // --- Dibujo ---

Â  function drawSafeZoneTop() {
Â  Â  ctx.fillStyle = '#084d00'; // Pasto
Â  Â  ctx.fillRect(0, 0, WIDTH, SAFE_ZONE_TOP_HEIGHT);

Â  Â  goalPositions.forEach((g, index) => {
Â  Â  Â  Â  if (goals[index]) {
Â  Â  Â  Â  Â  Â  // Rana estÃ¡tica en meta
Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  ctx.translate(g.x + g.width/2, g.height/2);
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#0f0';
Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  ctx.arc(0, 0, FROG_SIZE / 2, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // Meta vacÃ­a
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#fff';
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  Â  Â  Â  ctx.setLineDash([5, 5]);Â 
Â  Â  Â  Â  Â  Â  ctx.strokeRect(g.x, g.y, g.width, g.height);
Â  Â  Â  Â  Â  Â  ctx.setLineDash([]);
Â  Â  Â  Â  }
Â  Â  });

Â  Â  // LÃ­nea divisoria inferior
Â  Â  ctx.strokeStyle = '#0ff';
Â  Â  ctx.lineWidth = 3;
Â  Â  ctx.beginPath();
Â  Â  ctx.moveTo(0, SAFE_ZONE_TOP_HEIGHT);
Â  Â  ctx.lineTo(WIDTH, SAFE_ZONE_TOP_HEIGHT);
Â  Â  ctx.stroke();
Â  }

Â  function drawRiver() {
Â  Â  ctx.fillStyle = '#0077bb';
Â  Â  ctx.fillRect(0, SAFE_ZONE_TOP_HEIGHT, WIDTH, RIVER_HEIGHT);
Â  }
Â Â 
Â  function drawMedian() {
Â  Â  Â  // NUEVA ZONA SEGURA ENTRE RÃO Y CARRETERA
Â  Â  Â  ctx.fillStyle = '#084d00'; // Pasto (mismo color que inicio/fin)
Â  Â  Â  const medianY = SAFE_ZONE_TOP_HEIGHT + RIVER_HEIGHT;
Â  Â  Â  ctx.fillRect(0, medianY, WIDTH, MEDIAN_HEIGHT);
Â  Â  Â Â 
Â  Â  Â  // LÃ­nea divisoria superior (RÃ­o) e inferior (Carretera)
Â  Â  Â  ctx.strokeStyle = '#fff';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.moveTo(0, medianY);
Â  Â  Â  ctx.lineTo(WIDTH, medianY);
Â  Â  Â  ctx.moveTo(0, medianY + MEDIAN_HEIGHT);
Â  Â  Â  ctx.lineTo(WIDTH, medianY + MEDIAN_HEIGHT);
Â  Â  Â  ctx.stroke();
Â  }

Â  function drawRoad() {
Â  Â  ctx.fillStyle = '#444';
Â  Â  const roadY = SAFE_ZONE_TOP_HEIGHT + RIVER_HEIGHT + MEDIAN_HEIGHT;
Â  Â  ctx.fillRect(0, roadY, WIDTH, ROAD_HEIGHT);

Â  Â  // LÃ­neas divisorias amarillas (punteadas)
Â  Â  const gap = LANE_HEIGHT;
Â  Â  ctx.fillStyle = 'yellow';
Â  Â  for (let i = 0; i < ROAD_LANES_COUNT; i++) {
Â  Â  Â  let y = roadY + i * gap + gap / 2;
Â  Â  Â  for (let x = 0; x < WIDTH; x += 30) {
Â  Â  Â  Â  ctx.fillRect(x, y - 2, 20, 4);
Â  Â  Â  }
Â  Â  }
Â  }

Â  function drawSafeZoneBottom() {
Â  Â  Â  ctx.fillStyle = '#084d00';Â 
Â  Â  Â  ctx.fillRect(0, HEIGHT - SAFE_ZONE_BOTTOM_HEIGHT, WIDTH, SAFE_ZONE_BOTTOM_HEIGHT);
Â  }

Â  function drawFrog() {
Â  Â  if (gameEnded || isRespawning) return; // No dibujamos si estÃ¡ muriendo/reapareciendo

Â  Â  ctx.save();
Â  Â  ctx.translate(frogX + FROG_SIZE / 2, frogY + FROG_SIZE / 2);
Â  Â  ctx.fillStyle = '#0f0';
Â  Â  ctx.strokeStyle = '#030';
Â  Â  ctx.lineWidth = 3;
Â  Â  ctx.beginPath();
Â  Â  ctx.shadowColor = '#0f0';
Â  Â  ctx.shadowBlur = 8;
Â  Â  ctx.arc(0, 0, FROG_SIZE / 2, 0, Math.PI * 2);
Â  Â  ctx.fill();
Â  Â  ctx.shadowBlur = 0;
Â  Â  ctx.stroke();
Â  Â  // ojos
Â  Â  ctx.fillStyle = '#fff';
Â  Â  ctx.beginPath();
Â  Â  ctx.arc(-4, -5, 4, 0, Math.PI * 2);
Â  Â  ctx.arc(4, -5, 4, 0, Math.PI * 2);
Â  Â  ctx.fill();

Â  Â  ctx.fillStyle = '#000';
Â  Â  ctx.beginPath();
Â  Â  ctx.arc(-4, -5, 2.5, 0, Math.PI * 2);
Â  Â  ctx.arc(4, -5, 2.5, 0, Math.PI * 2);
Â  Â  ctx.fill();

Â  Â  ctx.restore();
Â  }
Â Â 
Â  function drawVehicles() {
Â  Â  vehicles.forEach(v => {
Â  Â  Â  ctx.save();
Â  Â  Â  ctx.fillStyle = v.color;
Â  Â  Â  ctx.strokeStyle = '#fff';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  ctx.shadowColor = v.color;
Â  Â  Â  ctx.shadowBlur = 8;
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.roundRect(v.x, v.y, v.width, v.height, 6);
Â  Â  Â  ctx.fill();
Â  Â  Â  ctx.shadowBlur = 0;
Â  Â  Â  ctx.stroke();
Â  Â  Â  // ruedas
Â  Â  Â  let wheelRadius = 4;
Â  Â  Â  let wheelY = v.y + v.height - wheelRadius - 2;
Â  Â  Â  ctx.fillStyle = '#222';
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(v.x + wheelRadius + 2, wheelY, wheelRadius, 0, Math.PI * 2);
Â  Â  Â  ctx.arc(v.x + v.width - wheelRadius - 2, wheelY, wheelRadius, 0, Math.PI * 2);
Â  Â  Â  ctx.fill();
Â  Â  Â  ctx.restore();
Â  Â  });
Â  }
Â Â 
Â  function drawLogs() {
Â  Â  logs.forEach(log => {
Â  Â  Â  ctx.save();
Â  Â  Â  ctx.fillStyle = log.color;
Â  Â  Â  ctx.strokeStyle = '#532a03';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.shadowColor = '#a76b30';
Â  Â  Â  ctx.shadowBlur = 10;
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.roundRect(log.x, log.y, log.width, log.height, 12);
Â  Â  Â  ctx.fill();
Â  Â  Â  ctx.shadowBlur = 0;
Â  Â  Â  ctx.stroke();
Â  Â  Â  ctx.restore();
Â  Â  });
Â  }
Â Â 
Â  function drawCrocodiles() {
Â  Â  crocodiles.forEach(croc => {
Â  Â  Â  ctx.save();
Â  Â  Â  ctx.fillStyle = croc.color;
Â  Â  Â  ctx.strokeStyle = '#143300';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.shadowColor = '#325012';
Â  Â  Â  ctx.shadowBlur = 10;
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.roundRect(croc.x, croc.y, croc.width, croc.height, 10);
Â  Â  Â  ctx.fill();
Â  Â  Â  ctx.shadowBlur = 0;
Â  Â  Â  ctx.stroke();

Â  Â  Â  // Ojos y boca (lÃ³gica simplificada)
Â  Â  Â  ctx.fillStyle = '#fff';
Â  Â  Â  ctx.fillRect(croc.x + 8, croc.y + 4, 4, 4);
Â  Â  Â  ctx.fillRect(croc.x + croc.width - 12, croc.y + 4, 4, 4);
Â  Â  Â Â 
Â  Â  Â  ctx.restore();
Â  Â  });
Â  }


Â  // --- LÃ³gica y Colisiones ---

Â  function updateObjects(objects) {
Â  Â  objects.forEach(obj => {
Â  Â  Â  obj.x += obj.speed * obj.direction;
Â  Â  Â  // Reinicio del objeto cuando sale de pantalla
Â  Â  Â  if (obj.direction === 1 && obj.x > WIDTH) {
Â  Â  Â  Â  obj.x = -obj.width - getRandomRange(100, 200);
Â  Â  Â  }
Â  Â  Â  if (obj.direction === -1 && obj.x < -obj.width) {
Â  Â  Â  Â  obj.x = WIDTH + getRandomRange(100, 200);
Â  Â  Â  }
Â  Â  });
Â  }
Â Â 
Â  function updateVehicles() { updateObjects(vehicles); }
Â  function updateLogs() { updateObjects(logs); }
Â  function updateCrocodiles() { updateObjects(crocodiles); }

Â  function isColliding(a, b) {
Â  Â  return a.x < b.x + b.width &&
Â  Â  Â  a.x + a.width > b.x &&
Â  Â  Â  a.y < b.y + b.height &&
Â  Â  Â  a.y + a.height > b.y;
Â  }

Â  function checkRoadCollisions() {
Â  Â  const roadTop = SAFE_ZONE_TOP_HEIGHT + RIVER_HEIGHT + MEDIAN_HEIGHT;
Â  Â  const roadBottom = HEIGHT - SAFE_ZONE_BOTTOM_HEIGHT;
Â  Â Â 
Â  Â  // Si la rana estÃ¡ en la zona de la carretera
Â  Â  if (frogY >= roadTop && frogY < roadBottom) {
Â  Â  Â  Â  const frogRect = { x: frogX, y: frogY, width: FROG_SIZE, height: FROG_SIZE };
Â  Â  Â  Â  for (let v of vehicles) {
Â  Â  Â  Â  Â  Â  let vehicleRect = { x: v.x, y: v.y, width: v.width, height: v.height };
Â  Â  Â  Â  Â  Â  if (isColliding(frogRect, vehicleRect)) {
Â  Â  Â  Â  Â  Â  Â  Â  loseLife('hit');Â 
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  }

Â  function checkRiverLogic() {
Â  Â  const riverTop = SAFE_ZONE_TOP_HEIGHT;
Â  Â  const riverBottom = SAFE_ZONE_TOP_HEIGHT + RIVER_HEIGHT;

Â  Â  // Si la rana estÃ¡ en la zona del rÃ­o
Â  Â  if (frogY >= riverTop && frogY < riverBottom) {
Â  Â  Â  Â  const frogRect = { x: frogX, y: frogY, width: FROG_SIZE, height: FROG_SIZE };
Â  Â  Â  Â  let carryingObject = null;

Â  Â  Â  Â  // Verificar si estÃ¡ sobre un objeto transportador
Â  Â  Â  Â  const transportObjects = [...logs, ...crocodiles];
Â  Â  Â  Â  for (let obj of transportObjects) {
Â  Â  Â  Â  Â  Â  let objRect = { x: obj.x, y: obj.y, width: obj.width, height: obj.height };
Â  Â  Â  Â  Â  Â  if (isColliding(frogRect, objRect)) {
Â  Â  Â  Â  Â  Â  Â  Â  carryingObject = obj;
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (carryingObject) {
Â  Â  Â  Â  Â  Â  // LÃ³gica de peligro (si aterriza en la cabeza/boca del cocodrilo)
Â  Â  Â  Â  Â  Â  if (carryingObject.type === 'croc' && checkCrocodileMouthCollision(frogRect, carryingObject)) {
Â  Â  Â  Â  Â  Â  Â  Â  loseLife('croc');
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // Mover la rana con el objeto
Â  Â  Â  Â  Â  Â  frogX += carryingObject.speed * carryingObject.direction;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â // No estÃ¡ sobre nada en el rÃ­o: AHOGADO
Â  Â  Â  Â  Â  Â  Â loseLife('drown');
Â  Â  Â  Â  Â  Â  Â return;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  constrainFrog();
Â  Â  }
Â  }

Â  function checkCrocodileMouthCollision(frogRect, croc) {
Â  Â  Â // Definimos la zona de peligro en el 20% frontal del cocodrilo
Â  Â  Â const dangerZoneWidth = croc.width * 0.2;Â 
Â  Â  Â const dangerZone = {
Â  Â  Â  Â  Â x: croc.direction === 1 ? croc.x : croc.x + croc.width - dangerZoneWidth,
Â  Â  Â  Â  Â y: croc.y,
Â  Â  Â  Â  Â width: dangerZoneWidth,
Â  Â  Â  Â  Â height: croc.height
Â  Â  Â };
Â  Â  Â return isColliding(frogRect, dangerZone);
Â  }


Â  function constrainFrog() {
Â  Â  if (frogX < 0) frogX = 0;
Â  Â  if (frogX + FROG_SIZE > WIDTH) frogX = WIDTH - FROG_SIZE;
Â  }

Â  function checkGoal() {
Â  Â  // Si la rana estÃ¡ en la zona superior de metas
Â  Â  if (frogY < SAFE_ZONE_TOP_HEIGHT) {
Â  Â  Â  Â  let completed = false;
Â  Â  Â  Â  const frogRect = { x: frogX, y: frogY, width: FROG_SIZE, height: FROG_SIZE };

Â  Â  Â  Â  for (let i = 0; i < GOAL_COUNT; i++) {
Â  Â  Â  Â  Â  Â  const goalRect = goalPositions[i];
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (isColliding(frogRect, goalRect)) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!goals[i]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  goals[i] = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  completed = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateGoalsDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ChocÃ³ con una rana ya colocada
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  loseLife('squish');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (completed) {
Â  Â  Â  Â  Â  Â  if (goals.every(g => g)) {
Â  Â  Â  Â  Â  Â  Â  Â  endGame(true); // Â¡Victoria!
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  respawnFrog();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // CayÃ³ en el pasto sin meta
Â  Â  Â  Â  Â  Â  loseLife('miss');
Â  Â  Â  Â  }
Â  Â  }
Â  }

Â  function respawnFrog() {
Â  Â  frogX = FROG_START_X;
Â  Â  frogY = FROG_START_Y;
Â  }

Â  function loseLife(reason) {
Â  Â  if (isRespawning || gameEnded) return;
Â  Â  isRespawning = true;

Â  Â  lives--;
Â  Â  updateLivesDisplay();

Â  Â  let msg = 'Has perdido una vida.';
Â  Â  switch(reason) {
Â  Â  Â  case 'hit': msg = 'ğŸš— Atropellado en la carretera.'; break;
Â  Â  Â  case 'drown': msg = 'ğŸŒŠ Ahogado en el rÃ­o.'; break;
Â  Â  Â  case 'croc': msg = 'ğŸŠ Devorado por cocodrilo.'; break;
Â  Â  Â  case 'miss': msg = 'âŒ Fallaste la meta.'; break;
Â  Â  Â  case 'squish': msg = 'ğŸ¸ Aplastado por otra rana.'; break;
Â  Â  }
Â  Â  completionMessageElem.textContent = msg;

Â  Â  if (lives <= 0){
Â  Â  Â  endGame(false);
Â  Â  Â  return;
Â  Â  }

Â  Â  setTimeout(() => {
Â  Â  Â  completionMessageElem.textContent = '';
Â  Â  Â  respawnFrog();
Â  Â  Â  isRespawning = false;
Â  Â  }, 1200);
Â  }

Â  function updateLivesDisplay() {
Â  Â  Â  let display = '';
Â  Â  Â  // Mostramos 3 corazones (verde si tiene vida, roto si no)
Â  Â  Â  for (let i = 0; i < 3; i++) {
Â  Â  Â  Â  Â  display += i < lives ? 'ğŸ’š' : 'ğŸ’”';
Â  Â  Â  }
Â  Â  Â  livesDisplayElem.textContent = display;
Â  }

Â  function updateGoalsDisplay() {
Â  Â  Â  const completedCount = goals.filter(g => g).length;
Â  Â  Â  goalsCompletedElem.textContent = `${completedCount}/${GOAL_COUNT}`;
Â  }


Â  // LÃ³gica de finalizaciÃ³n para salir al programa padre
Â  function endGame(win) {
Â  Â  if (gameEnded) return;
Â  Â  gameEnded = true;
Â  Â  completionMessageElem.textContent = win ? 'ğŸ‰ Â¡VICTORIA! Todas las metas completadas.' : 'ğŸ’€ JUEGO TERMINADO. Sin vidas.';

Â  Â  setTimeout(() => {
Â  Â  Â  try {
Â  Â  Â  Â  if (window.parent && window.parent !== window && typeof window.parent.endGame === 'function') {
Â  Â  Â  Â  Â  window.parent.endGame(win);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  window.location.href = '/';
Â  Â  Â  Â  }
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  window.location.href = '/';
Â  Â  Â  }
Â  Â  }, 3000);Â 
Â  }

Â  function resetGame(fullReset = false) {
Â  Â  if (fullReset) {
Â  Â  Â  Â  lives = 3;
Â  Â  Â  Â  initGoals();
Â  Â  Â  Â  updateLivesDisplay();
Â  Â  }
Â  Â Â 
Â  Â  respawnFrog();Â 
Â  Â  initVehicles();
Â  Â  initLogs();
Â  Â  initCrocodiles();
Â  Â  gameEnded = false;
Â  Â  isRespawning = false;
Â  Â  completionMessageElem.textContent = '';
Â  Â  requestAnimationFrame(gameLoop);
Â  }


Â  // --- InicializaciÃ³n y Bucle Principal ---

Â  // roundRect polyfill
Â  if (!CanvasRenderingContext2D.prototype.roundRect) {
Â  Â  CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
Â  Â  Â  if (w < 2 * r) r = w / 2;
Â  Â  Â  if (h < 2 * r) r = h / 2;
Â  Â  Â  this.beginPath();
Â  Â  Â  this.moveTo(x + r, y);
Â  Â  Â  this.arcTo(x + w, y, x + w, y + h, r);
Â  Â  Â  this.arcTo(x + w, y + h, x, y + h, r);
Â  Â  Â  this.arcTo(x, y + h, x, y, r);
Â  Â  Â  this.arcTo(x, y, x + w, y, r);
Â  Â  Â  this.closePath();
Â  Â  Â  return this;
Â  Â  }
Â  }

Â  initGoalPositions();Â 
Â  resetGame(true);Â 

Â  function gameLoop() {
Â  Â  if (gameEnded) return;

Â  Â  ctx.clearRect(0, 0, WIDTH, HEIGHT);

Â  Â  // DIBUJO DE FONDOS
Â  Â  drawSafeZoneTop();
Â  Â  drawRiver();
Â  Â  drawMedian(); // DIBUJO DE LA NUEVA ZONA SEGURA
Â  Â  drawRoad();
Â  Â  drawSafeZoneBottom();Â 

Â  Â  // LÃ“GICA DE MOVIMIENTO
Â  Â  updateVehicles();
Â  Â  updateLogs();
Â  Â  updateCrocodiles();

Â  Â  // Dibujo de elementos en movimiento
Â  Â  drawLogs();
Â  Â  drawCrocodiles();
Â  Â  drawVehicles();

Â  Â  // ComprobaciÃ³n de Colisiones (Solo si no estÃ¡ reapareciendo)
Â  Â  if (!isRespawning) {Â 
Â  Â  Â  Â  checkRiverLogic();Â 
Â  Â  Â  Â  checkRoadCollisions();
Â  Â  Â  Â  checkGoal();Â 
Â  Â  }

Â  Â  drawFrog();

Â  Â  requestAnimationFrame(gameLoop);
Â  }

Â  // --- Input handlers (Teclado y D-Pad) ---

Â  function attemptMove(dir) {
Â  Â  if (gameEnded || isRespawning) return; // No se mueve mientras muere/reaparece

Â  Â  let newX = frogX;
Â  Â  let newY = frogY;
Â  Â  switch (dir) {
Â  Â  Â  case 'left': newX -= FROG_STEP; break;
Â  Â  Â  case 'right': newX += FROG_STEP; break;
Â  Â  Â  case 'up': newY -= FROG_STEP; break;
Â  Â  Â  case 'down': newY += FROG_STEP; break;
Â  Â  }

Â  Â  // LÃ­mite Horizontal
Â  Â  if (newX < 0) newX = 0;
Â  Â  if (newX + FROG_SIZE > WIDTH) newX = WIDTH - FROG_SIZE;
Â  Â Â 
Â  Â  // LÃ­mite Vertical y ajuste de posiciÃ³n
Â  Â  if (dir === 'up' || dir === 'down') {
Â  Â  Â  Â  const currentLaneY = Math.round((frogY - (FROG_STEP - FROG_SIZE) / 2) / FROG_STEP) * FROG_STEP;
Â  Â  Â  Â  const nextY = dir === 'up' ? currentLaneY - FROG_STEP : currentLaneY + FROG_STEP;
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Ajustamos la posiciÃ³n Y al centro del nuevo carril
Â  Â  Â  Â  newY = nextY + (LANE_HEIGHT - FROG_SIZE) / 2;

Â  Â  Â  Â  // Limites absolutos
Â  Â  Â  Â  if (newY < 0) newY = 0;Â 
Â  Â  Â  Â  if (newY > HEIGHT - FROG_STEP) newY = HEIGHT - FROG_STEP + (FROG_STEP - FROG_SIZE) / 2;
Â  Â  }


Â  Â  frogX = newX;
Â  Â  frogY = newY;
Â  Â Â 
Â  Â  constrainFrog();
Â  }
Â Â 
Â  // Eventos de teclado
Â  window.addEventListener('keydown', e => {
Â  Â  if (gameEnded || isRespawning) return;
Â  Â  const key = e.key.toLowerCase();
Â  Â  if (['arrowup', 'w', 'arrowdown', 's', 'arrowleft', 'a', 'arrowright', 'd'].includes(key)) {
Â  Â  Â  Â  e.preventDefault();Â 
Â  Â  Â  Â  if (key === 'arrowup' || key === 'w') attemptMove('up');
Â  Â  Â  Â  else if (key === 'arrowdown' || key === 's') attemptMove('down');
Â  Â  Â  Â  else if (key === 'arrowleft' || key === 'a') attemptMove('left');
Â  Â  Â  Â  else if (key === 'arrowright' || key === 'd') attemptMove('right');
Â  Â  }
Â  });
Â Â 
Â  // Eventos de los botones del D-Pad
Â  document.querySelectorAll('.d-pad-btn').forEach(button => {
Â  Â  button.addEventListener('click', e => {
Â  Â  Â  e.preventDefault();
Â  Â  Â  attemptMove(button.dataset.direction);
Â  Â  });
Â  });

})();
</script>

</body>
</html>